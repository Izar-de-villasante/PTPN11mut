---
title: "PTPN11 mutagenesis"
author: "Izar de Villasante"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: hide
    toc: yes
    toc_depth: 2
    toc_float: yes
tags:
- R Markdown
- plot
- regression
categories: R
params:
  prefix1: ./data-raw/batch2/mut_batch2
  prefix2: ./data-raw/batch1/PTPN11_trimmed
runtime: shiny
resource_files:
- data/main_mut_batch2.rds
- data/main_PTPN11_trimmed.rds
- data/main_mut_batch2.rds
- data/main_PTPN11_trimmed.rds
---
<style>
.main-container {
  max-width: 100% !important;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



```{css toc-content, echo = FALSE}
#TOC {
  right: 70px;
  margin: 20px 0px 25px 0px;
}

.main-container {
    margin-left: 10px;
    margin-right: 10px !important;
    max-width: 98% !important;
}
```
# Report {.tabset}

## Functions:

In this section the user defined functions for the rest of the project are specified

```{r functions}
library(circlize)
library(RColorBrewer)
library(DT)

# Shannon diversity function to compare homogeneity of mutated proteins for each
# position of the sequence:
diversity <-function(x){
  N = sum(x)
  p = x/N
  H = -sum(p*log(p))
  H
}

# Color functions:
#color_function for heatmap continuos scales:

col_fun <- colorRamp2(breaks = c(0.1,0.3,0.4,0.68,1),
                      c(blues9[9],
                        blues9[5],
                        "white",
                        RColorBrewer::brewer.pal(11,"Paired")[11],
                        "red")
                      )
col_fun2 <- colorRamp2(breaks = c(0,1),
                      c("white",
                        "red")
                      )

make_rel_counts<-function(idvars,LHSvars,RHSvar, value.var, batches,n_batches){
    
  if(is.null(n_batches) | length(n_batches != length(batches))) n_batches <- 1:length(batches)
  aacounts_list <- list()
  relcounts_list <- list()
  # new.vars <- with(batches[[1]],unique(get(RHSvar)))
  for (n in 1:length(n_batches)){
    
    aacounts <- batches[[n]][,list( aa_counts= sum(aa_counts), batch=n_batches[n]),by=idvars]
    names(aacounts)[length(LHSvars)+1]<-value.var
    aacounts_list[[paste0("aacounts_",n_batches[n])]] <- aacounts
    
    rel_counts<- data.table::dcast.data.table(
      data =aacounts,
      formula = as.formula(paste(paste(LHSvars,collapse = ' + '), "~", RHSvar)),
      value.var = value.var
      )
    new.vars <- setdiff(colnames(rel_counts), LHSvars)
    rel_counts[,(new.vars):=.SD/rowSums(.SD),.SDcols = new.vars]
    relcounts_list[[paste0("rel_counts_b",n_batches[n])]] <- rel_counts
  }
  
  merge_dt<-rbindlist(batches)
  aacounts_merge<-merge_dt[,list( aa_counts= sum(aa_counts), batch="merge"),by=idvars]
  rel_counts<- data.table::dcast.data.table(
      data =aacounts_merge,
      formula = as.formula(paste(paste(LHSvars,collapse = ' + '), "~", RHSvar)),
      value.var = value.var
      )
  rel_counts[,(new.vars):=.SD/rowSums(.SD),.SDcols = new.vars]

  relcounts_list[["rel_counts_merge"]] <- rel_counts
  return(rbindlist( relcounts_list))
}

## Data tables:

myModal <- function() {
  div(id = "test",
      modalDialog(downloadButton("download1","Download data as csv"),
                  br(),
                  br(),
                  downloadButton("download2","Download data as excel"),
                  easyClose = TRUE, title = "Download Table")
  )
}
renderDT<- function(data){
  

mt  <- DT::renderDataTable(
                        DT::datatable(
                            { data},
                            filter = 'top',
                            # selection = list(mode = 'multiple', selected = c(1:10), target = 'column', selectable = c(-2, -3)),
                            fillContainer = F,
                            # style =  "bootstrap",

                            extensions = 'Buttons',

                            options = list(
                                paging = TRUE,
                                searching = TRUE,
                                fixedColumns = TRUE,
                                autoWidth = FALSE,
                                scrollX=TRUE,
                                digits=4,
                                ordering = TRUE,
                                dom = 'Bfrtip',
                                buttons = list(
                                  list(
                                    extend = "collection",
                                    text = 'download entire dataset',
                                    action = DT::JS("function ( e, dt, node, config ) {
                                                    Shiny.setInputValue('test', true, {priority: 'event'});
                                                    }")
                                  ),
                                  'copy',
                                  'csv',
                                  'excel'
                                ),

                            class = "display",
                            server=TRUE
                       ),
                       ) |> formatRound(which(sapply(data,is.double)),4),
                     
)
  shiny::observeEvent(input$test, {
    print("hello")
    showModal(myModal())
  })
  
  
  output$download1 <- shiny::downloadHandler(
    filename = function() {
      paste("data-", Sys.Date(), ".csv", sep="")
    },
    content = function(file) {
      write.csv(data, file)
    }
  )
  
  output$download2 <- shiny::downloadHandler(
    filename = function() {
      paste("data-", Sys.Date(), ".xlsx", sep="")
    },
    content = function(file) {
      writexl::write_xlsx(data, file)
    }
  )
  mt
}

```



## Prepare data:

### Load:

First the codon and aminoacid counts per postion of all batches must be loaded and also the original aminoacid sequence of our protein:

```{r load data}
library(data.table)
main_b1 <- readRDS(paste0("./data/main_",basename(params$prefix1),".rds"))
main_b2 <- readRDS(paste0("./data/main_",basename(params$prefix2),".rds"))
wt_seq<-setorder(main_b1[,unique(pos),by=wt_aa],V1)$wt_aa
```

### annotate batch and merge:

Now we can put together all this data in the same dataset, from now on the `main` dataset. 


```{r}
# add batch and merge:
main_b1$batch=as.factor(1)
main_b2$batch=as.factor(2)
main<-rbind(main_b1,main_b2)
# # Counts as integers:
# count_cols <- c("aa_counts","codon_counts")
# main[,(count_cols):=lapply(.SD, as.integer),.SDcols=count_cols]
data.table::setorder(main,pos,-aa_counts, -codon_counts)
#DT::renderDataTable(main,filter="top")

```

## Color styles

```{r}
n<- length(unique(main$aa_sub))
pals::pal.bands(pals::alphabet(n))
aa_cols<-pals::alphabet(n)
names(aa_cols)<-unique(main$aa_sub)
```

## Analysis {.active}

This dataset contains the following information:

1. **wt_aa** *(Wildtype amino acid)*: Amino-acid found in the wild type sequence for that position.
2. **wt_codons** *(Wildtype codon)*: The genetic code in the wild type coding sequence.
3. **codon_sub** *(codon substitution)*: The genetic code of the altered codon resulting from the mutagenesis process.
4. **aa_sub** *(amino acid substitution)*: The three-letter symbol of the altered aminoacid. *(translated from the codon substitution)*
5. **dist** *(mutated bases)*: the number of bases that where changed to go from wt_codons to codon_sub
6. **change**: The bases that have been mutated *(wildtype)* --to-> *(altered)*.
7. **pos** *(aminoacid position)*: The position in the protein sequence.
8. **codon_counts**: The number of times a particular codon alteration has been called by the variation caller tool in a given position of the sequence.
9. **aa_counts**: The number of times a particular aminoacid substitution has been observed in that give position.

Bear in mind that multiple codons code for the same aminoacid, so aa_counts is the sum of all the codon -> codon alterations that lead to the same aa -> aa alteration.

You can take a look at it in the table below and also download it pressing the download entire dataset button:

```{r}
mt<-renderDT(main)
mt
```


We are interested mainly in amino acids so we can merge and abbreviate this table as shown below:

```{r}
merge_dt<-rbindlist(list(main_b1,main_b2))
aacounts_merge<-merge_dt[,list( aa_counts= sum(aa_counts), batch="merge"),by=c("pos","wt_aa","aa_sub")]
main2<-rbindlist(list(aacounts_merge,merge_dt[,.SD,.SDcols=names(aacounts_merge)]))
# render main data with all the datasets (batch1,batch2...merge)
mt2<-renderDT(main2)
mt2
```

### Calculate relative aminoacids:

The `aa_counts` & `codon_counts` variables store the number of absolute observations of each alteration for each posisiton. Nevertheless some positions are mutated more often than others, so to get an accurate idea of the conversion rate between different aminoacids, the absolute counts are transformed in relative counts. 
The next table shows the proportions of each wildtype amino acid mutation into each new resulting aminoacid. Therefore, the conversion between aminoacids can be compared between positions.  

```{r}
# Function declared above makes one table from multiple main_batch tables and a merged statistic  #####
idvars<-c("pos","wt_aa","aa_sub") # variables you want to take from main
LHSvars<-c("batch","pos","wt_aa") # variables with explainatory data
RHSvar<-"aa_sub"                  # variable you want to expand 
value.var<-"aa_counts"            # values for the variable to expand can be = RHSvar (default behavior)
batches<-list(main_b1,main_b2)
n_batches<-NULL
############################################

relcounts<-make_rel_counts(idvars,LHSvars,RHSvar, value.var, batches,n_batches)
data.table::setorder(relcounts,pos,batch)
# DT::renderDataTable(relcounts,filter="top")
relcountsDT<-renderDT(relcounts)
relcountsDT

```

### Make chunks of data for the plots

Select the number of observations in each chunk:

```{r}
### Split in chunks to better visualize



sliderInput("chunk", label = h5("Number of observations per chunk:"), min = 1, 
        max = max(length(wt_seq)), value = 100)


# n_obs_per_chunk <-observeEvent(input$chunk, { 
# var<<-input$days
# })
# print(n_obs_per_chunk)    
chk <- reactive({
  chunks<-parallel::splitIndices(length(wt_seq), ncl = ceiling(length(wt_seq)/input$chunk))
  group<-unlist(lapply(chunks,function(x)rep(paste("pos:",paste(range(x),collapse = " - ")),length(x) )))
  relcounts$group<-group[relcounts$pos]
  # rel<-relcounts[,list(n_obs=length(unique(pos))),by=c("group")]
  relcounts
})

DT::renderDataTable(DT::datatable({
  relcounts<-chk()
  rel<-relcounts[,list(n_obs=length(unique(pos))),by=c("group")]
  rel
}))


```


### Plots

#### Relative amino acid conversion barplot

In this interactive plot the fraction of each aminoacid conversion can be explored. Fell free to swap between batches and reordering the sequence either by original protein sequence or by alphabetical order of the aminoacids.

```{r}
ct<-RGenetics::geneticCodeTable()
setDT(ct)
ct<-ct[,.SD,.SDcols=c("AminoAcids","AA")]|>unique()

setkeyv(ct,"AminoAcids")
wt_aa_one <- ct[wt_seq,c("AA","AminoAcids")]
wt_aa_one[,idx:=paste(AA,seq_along(1:.N),sep="_")]
wt_aa_one[,lab:=paste(AA,seq_along(1:.N),sep="_")]
# relcounts$aa_one<- wt_aa_one[relcounts$pos,idx]
# relcounts$labs<-wt_aa_one[relcounts$pos,paste(AA,AminoAcids,sep=" - ")]

# prot_pdata<-data.table::melt.data.table(relcounts,id.vars = c("batch","pos","wt_aa","aa_one","aa_cols"))

```

# ```{r, echo = FALSE}
# library(rmdexamples)
# kmeans_cluster(iris)
# ```


```{r, echo=FALSE}
library(ggplot2)
library(magrittr)
gg_facet_nrow_ng <- function(p){
 assertive.types::assert_is_any_of(p, 'ggplot')
 p %>%
   ggplot2::ggplot_build() %>%
   magrittr::extract2('layout') %>%
   magrittr::extract2('layout') %>%
   magrittr::extract2('ROW') %>%
   unique() %>%
   length()
}

selectInput("batch", label = "Select batch:",
              choices = levels(factor(relcounts$batch)), selected = "merge")
selectInput("order", label = "Order of observations:",
              choices = c("wild type"="pos","AA"="aa_one"), selected = "wild type")


pdata <- reactive({
  relcounts<-subset(chk(), batch == input$batch)
  relcounts$aa_one<- wt_aa_one[relcounts$pos,idx]
  relcounts$aa_cols<-sapply(
  relcounts$wt_aa,
  function(x) unname(aa_cols[which( names(aa_cols) %in% x)])
)
  prot_pdata<-data.table::melt.data.table(relcounts,id.vars = c("batch","group","pos","wt_aa","aa_one","aa_cols"))
  prot_pdata
})

p1<-reactive({
  ggplot()+
  ggtitle("Relative amino acid conversion by position.")+

  geom_bar(data=pdata(),
           aes(x=factor(.data[[input$order]]),y=value,fill=variable,group=value),
           stat="identity",
           position="stack")+
  scale_fill_manual(values = aa_cols) +
  # scale_x_discrete(name="Amino acid",labels=paste)+
  facet_wrap(~group,scales='free',as.table = T,ncol=1)+theme(axis.text.x = element_text(angle = 90))
})

he <- reactive(gg_facet_nrow_ng(p1()))
shiny::renderPlot({p1() }, height = function(){he()*100})#height = 4000)

```


### Aminoacid diversity conversion

The above plots are helpful to compare the different alterations/mutations that are observed for for each position in the sequence. Nevertheless, data has been transformed to relative proportions for this purpose and so, it is more complicated to get a general idea on how homogeneus each group may be.
A good way to address the heterogeneity in a given set of observations is to compute its diversity. So in the next plot each observation represents the diversity of the mutated aminoacid counts `aa_counts` for each wildtype aminoacid `wt_aa` in the protein of interest.

There are many ways to measure the amino acid conversion diversity in order to compare homogeneity between. One of the most common methods is the shannon diversity index:

$$^{q}\!D={1 \over M_{q-1}}={1 \over {\sqrt[{q-1}]{\sum _{i=1}^{R}p_{i}p_{i}^{q-1}}}}=\left({\sum _{i=1}^{R}p_{i}^{q}}\right)^{1/(1-q)}$$


# ```{r}
# main2<-rbindlist(list(aacounts_merge,merge_dt[,.SD,.SDcols=names(aacounts_merge)]))
# tab2<-main2[aa_counts > 3,list(N=length(unique(aa_sub)),diversity=diversity(aa_counts)),by=c("pos","batch")]
# g<-unique(relcounts[,c("pos","group")])
# setkey(g,pos)
# tab2$group<-g[tab2$pos]$group
```

# ```{r, echo = FALSE}
# library(rmdexamples)
# kmeans_cluster(iris)
# ```


<!-- ```{r, echo = FALSE} -->
<!-- library(shiny) -->
<!-- library(ggplot2) -->
<!-- library(Cairo)   # For nicer ggplot2 output when deployed on Linux -->

<!-- # https://shiny.rstudio.com/gallery/plot-interaction-selecting-points.html -->


<!--   ui <- fluidPage( -->
<!--     column(8, -->
<!--       # column(width = 12, -->
<!--              #box(style='width:400px;overflow-x: scroll;height:400px;overflow-y: scroll;', -->
<!--                  plotOutput("plot1", height = 400, #height = (250*length(unique(tab2$group))), -->
<!--                             # Equivalent to: click = clickOpts(id = "plot_click") -->
<!--                             click = "plot1_click", -->
<!--                             brush = brushOpts( -->
<!--                               id = "plot1_brush" -->
<!--                               ) -->
<!--                  ) -->
<!--                             # ) -->
<!--                  # ) -->

<!--     ), -->
<!--     column(4, -->
<!--       fluidRow(width = 12, -->
<!--         h4("Points near click"), -->
<!--         verbatimTextOutput("click_info") -->
<!--       ), -->
<!--       fluidRow(width = 12, -->
<!--         h4("Brushed points"), -->
<!--         verbatimTextOutput("brush_info") -->
<!--       ) -->
<!--     ) -->
<!--   ) -->

<!--   server <- function(input, output) { -->
<!--     output$plot1 <- renderPlot({ -->
<!--         p<-ggplot2::ggplot(data=tab2,aes(x=pos,y=diversity,color=batch))+ -->
<!--         ggplot2::ggtitle("Diversity of aminoacid conversion by position.")+ -->
<!--         ggplot2::geom_point()+ -->
<!--         ggplot2::geom_line()+ -->
<!--         facet_wrap(~group,scales='free',as.table = T,ncol=1)+theme(axis.text.x = element_text(angle = 90)) -->
<!--         print(p) -->
<!--     }) -->
<!--     output$click_info <- renderPrint({ -->
<!--         # Because it's a ggplot2, we don't need to supply xvar or yvar; if this -->
<!--         # were a base graphics plot, we'd need those. -->
<!--         nearPoints(tab2, input$plot1_click, addDist = TRUE) -->
<!--     }) -->
<!--     output$brush_info <- renderPrint({ -->
<!--       brushedPoints(tab2, input$plot1_brush) -->
<!--     }) -->

<!--   } -->


<!-- shinyApp(ui, server,options = list( height = 400)) -->
<!-- ``` -->